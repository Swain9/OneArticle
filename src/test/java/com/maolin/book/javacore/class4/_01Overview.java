package com.maolin.book.javacore.class4;

import com.maolin.book.javacore.UsefulUtil;
import org.junit.Test;

/**
 * 第 4 章 对 象 与 类
 *
 * @author zhangmaolin
 * @date 2018-11-22 23:29
 * @since 0.0.1
 */
public class _01Overview extends UsefulUtil {


    /**
     * 4.1 面向对象程序设计概述
     * 面向对象程序设计（简称 OOP)
     * 面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实
     * 现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象， 还是
     * 从外界购买对象完全取决于开发项目的预算和时间。但是， 从根本上说， 只要对象能够满足
     * 要求，就不必关心其功能的具体实现过程。在 OOP 中， 不必关心对象的具体实现，只要能
     * 够满足用户的需求即可
     */
    @Test
    public void test0() {

    }

    /**
     * 4.1.1 类
     * 类（ class) 是构造对象的【模板】或【蓝图】。我们可以将类想象成制作小甜饼的切割机，将对
     * 象想象为小甜饼。由类构造【construct】对象的过程称为创建类的实例 【instance】.
     */
    @Test
    public void test1(){

        //【封装】（ encapsulation , 有时称为数据隐藏） 是与对象有关的一个重要概念。从形式上看，
        //封装不过是将【数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式】。对象
        //中的数据称【为实例域（ instance field )】, 操纵数据的过程称为【方法（ method ) 】。对于每个特定的
        //类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前【状态（ state )】。
        //无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

        //实现封装的关键在于【绝对不能】让类中的方法直接地访问【其他类的实例域】。程序仅通过对
        //象的方法与对象数据进行交互。封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性
        //的关键。 这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数

        //OOP 的另一个原则会让用户自定义 Java 类变得轻而易举，这就是：可以通过扩展一个
        //类来建立另外一个新的类。事实上， 在 Java 中， 所有的类都源自于一个“ 神通广大的超类”，
        //它就是 Object。
        //在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类
        //中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个
        //类的过程称为【继承（inheritance)】
    }

}
